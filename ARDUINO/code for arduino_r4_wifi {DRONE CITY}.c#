 //DRONE CITY CODE (no bugs)
 //©lazpal2025


//code for arduino_r4_wifi {DRONE CITY}

#include <WiFiS3.h>              // Βιβλιοθήκη WiFi
#include <ArduinoHttpClient.h>   // Βιβλιοθήκη HttpClient
#include <Arduino_LED_Matrix.h>  // Βιβλιοθήκη LED Matrix
#include <DFRobot_GNSS.h>        // Βιβλιοθήκη GNSS
#include "HUSKYLENS.h"           // Βιβλιοθήκη HuskyLens
#include <Wire.h>
#include <SPI.h>
#include <Adafruit_Sensor.h>
#include "Adafruit_BME680.h"

#define I2C_COMMUNICATION  //use I2C for communication, but use the serial port for communication if the line of codes were masked (GNSS)


DFRobot_GNSS_I2C gnss(&Wire, GNSS_DEVICE_ADDR);

//Adafruit_BME680 pins
#define BME_SCK 13
#define BME_MISO 12
#define BME_MOSI 11
#define BME_CS 10

#define SEALEVELPRESSURE_HPA (1013.25)

//smoke sensor
int sensorPin = A0;
int sensorValue = 0;

//Adafruit_BME680 bme(&Wire); // I2C
//Adafruit_BME680 bme(&Wire1); // example of I2C on another bus
Adafruit_BME680 bme(BME_CS);  // hardware SPI

// Αντικείμενο για τον έλεγχο του HuskyLens
HUSKYLENS huskylens;


String aqi = "no_data";
String arduinoStatus = "begin";  // Μεταβλητή για την κατάσταση του Arduino
bool Detect_Fire = false;

char ssid[] = "...";  // Όνομα WiFi SSID
char pass[] = ".....";  // Κωδικός πρόσβασης WiFi

char server[] = "drone-city-api.glitch.me";  // IP ή URL του server API οχι https:
int port = 80;                               // Πόρτα του API (χρησιμοποιήστε 443 για HTTPS)

WiFiClient wifi;                                     // Δημιουργία αντικειμένου WiFi client
HttpClient client = HttpClient(wifi, server, port);  // Δημιουργία αντικειμένου HttpClient με τον WiFi client, server και πόρτα

/* Baud rate cannot be changed */
#if defined(ARDUINO_AVR_UNO)
SoftwareSerial mySerial(4, 5);
DFRobot_GNSS_UART gnss(&mySerial, 9600);
#endif

ArduinoLEDMatrix matrix;  // Δημιουργία αντικειμένου για την LED Matrix

void setup() {
  Serial.begin(9600);  // Αρχικοποίηση σειριακής επικοινωνίας
  while (!Serial) {
    Serial.println("sirial start...");  // Αναμονή για σύνδεση στη σειριακή θύρα
  }

  matrix.begin();
  matrix.loadSequence(LEDMATRIX_ANIMATION_TETRIS_INTRO);
  matrix.play(true);

  Serial.println("DRONE CITY START");

  // Σύνδεση στο WiFi
  WiFi.begin(ssid, pass);
  checkWiFiConnection();
  printWifiStatus();


  //Adafruit_BME680
  Serial.println(F("BME680 test"));

  if (!bme.begin()) {
    Serial.println("Could not find a valid BME680 sensor, check wiring!");
    arduinoStatus = ("Could not find a valid BME680 sensor, check wiring!");
  } else {
    Serial.println("Adafruit_BME680 ok");
    arduinoStatus = ("OK");
  }

  // Set up oversampling and filter initialization
  bme.setTemperatureOversampling(BME680_OS_8X);
  bme.setHumidityOversampling(BME680_OS_2X);
  bme.setPressureOversampling(BME680_OS_4X);
  bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
  bme.setGasHeater(320, 150);  // 320*C for 150 ms

  // Αρχικοποίηση GNSS
  arduinoStatus = "Sensor Error GNSS" + arduinoStatus;  // Ενημέρωση του status αν αποτύχει η σύνδεση με τον αισθητήρα
  Serial.println("Δεν βρέθηκαν συσκευές GNSS!");
  delay(500);

  gnss.enablePower();  // Ενεργοποίηση GNSS
  gnss.setGnss(eGPS_BeiDou_GLONASS);
  gnss.setRgbOn();
  
    Wire.begin();
  // Αρχικοποίηση HuskyLens
  if (!huskylens.begin(Wire)) {
    Serial.println("Δεν μπόρεσε να βρεθεί το HuskyLens!");
    arduinoStatus = "HuskyLens error " + arduinoStatus;
  }else {Serial.println("Το HuskyLens είναι έτοιμο");}
  
  huskylens.clearCustomText();
  huskylens.customText("DRONE CITY begin...", 140, 200);

  // Επιλογή λειτουργίας Object Classification (Ταξινόμηση αντικειμένων)
  huskylens.writeAlgorithm(ALGORITHM_OBJECT_CLASSIFICATION);

  
  huskylens.setCustomName("fire", 5);
  huskylens.setCustomName("fire", 6);
  huskylens.setCustomName("fire", 7);

  pinMode(4, OUTPUT);

  huskylens.customText(arduinoStatus, 0, 200);
  Serial.println("");
  huskylens.loadModelFromSDCard(1);

  String jsonData = "{\"arduino_status\":\"" + String(arduinoStatus) + "\"}";
  client.post("/data", "application/json", jsonData);
  Serial.println("Arduino status send.....");
  Serial.println(arduinoStatus);

if (arduinoStatus == "HuskyLens error Sensor Error GNSSCould not find a valid BME680 sensor, check wiring!") {
Serial.println("-- !!! Begin Fald !!! -- check wiring! --");
arduinoStatus = "- Begin Fald......... -";
Serial.println("|||||>--- Arduino Reset ---<|||||");
String jsonData = "{\"arduinoStatus\":\"" + String(arduinoStatus) + "\"}";
client.post("/data", "application/json", jsonData);
analogWrite(4, HIGH);

delay(500);
analogWrite(7, LOW);
delay(500);
}
}

void loop() {
  arduinoStatus = "OK";
  // Διαχείριση των LED
  for (int i = 0; i <= 255; i++) {
    analogWrite(4, i);

    delay(10);
  }

  for (int i = 255; i >= 0; i--) {
    analogWrite(4, i);

    delay(10);
  }


  // Έλεγχος κατάστασης Arduino
  if (arduinoStatus != "OK") {
    analogWrite(4, HIGH);

    Serial.println("arduinoStatus: error  :" + arduinoStatus);
    delay(500);
  }
  if (arduinoStatus == "OK") {
    analogWrite(4, 0);
  }

  // Ανάγνωση πολλαπλών μετρήσεων από τους αισθητήρες και υπολογισμός του μέσου όρου

  sTim_t utc = gnss.getUTC();
  sTim_t date = gnss.getDate();
  sLonLat_t lat = gnss.getLat();
  sLonLat_t lon = gnss.getLon();
  double high = gnss.getAlt();
  uint8_t starUserd = gnss.getNumSatUsed();
  double sog = gnss.getSog();
  double cog = gnss.getCog();

  Serial.println("");
  huskylensData();
  Serial.println("");

  if (!bme.performReading()) {
    Serial.println("Failed to perform reading :(");
    arduinoStatus = "Sensor Error BME680";  // Ενημέρωση του status αν ο αισθητήρας δίνει μη έγκυρα δεδομένα
    Serial.println("<---Sensor Error---> Sensor Error BME680");
    matrix.loadFrame(LEDMATRIX_UNO);
    analogWrite(4, HIGH);
    //return;
  }


  if (bme.temperature < -10 || bme.humidity <= 0 || bme.temperature > 50 || bme.humidity > 95) {
    arduinoStatus = "Sensor Error BME680";  // Ενημέρωση του status αν ο αισθητήρας δίνει μη έγκυρα δεδομένα
    Serial.println("<---Sensor Error---> Sensor Error BME680");
    matrix.loadFrame(LEDMATRIX_UNO);
    analogWrite(4, HIGH);
    delay(500);
  }



  if (arduinoStatus == "Sensor Error BME680") {
    Serial.println("- BME680 no data -");
    Serial.println("Air Quality: no data :( ");
    aqi = "no data :(";
  } else {
    // Get gas resistance in KOhms
    float gas_resistance_kohms = bme.gas_resistance / 1000.0;

    Serial.print("Gas resistance: ");
    Serial.print(gas_resistance_kohms);
    Serial.println(" KOhms");
    // Determine air quality based on gas resistance
    if (gas_resistance_kohms > 50) {
      Serial.println("Air Quality: Good :) ");
      aqi = "Good :)";
    } else if (gas_resistance_kohms > 30 && gas_resistance_kohms <= 50) {
      Serial.println("Air Quality: Moderate :) ");
      aqi = "Moderate :)";
    } else if (gas_resistance_kohms > 20 && gas_resistance_kohms <= 30) {
      Serial.println("Air Quality: Acceptable :| ");
      aqi = "Acceptable :|";
    } else if (gas_resistance_kohms > 10 && gas_resistance_kohms <= 20) {
      Serial.println("Air Quality: Poor :( ");
      aqi = "Poor :(";
    } else if (gas_resistance_kohms <= 0 && gas_resistance_kohms <= 0) {
      Serial.println("Air Quality: no data :( ");
      aqi = "no data :(";
    } else if (gas_resistance_kohms <= 10) {
      Serial.println("Air Quality: Hazardous :\ ");
      aqi = "Hazardous :\ ";
    } else {
      Serial.println("Air Quality: no data :( ");
      aqi = "no data :(";
    }
  }

  if (sog == 0.00) { Serial.println("<---Sensor Error---> GPS(no signal)"); }

  // Εκτύπωση δεδομένων αισθητήρων
  Serial.println("");
  Serial.println("Δεδομένα από τους αισθητήρες {");

  Serial.print("Temperature = ");
  Serial.print(bme.temperature);
  Serial.println(" *C");

  Serial.print("Pressure = ");
  Serial.print(bme.pressure / 100.0);
  Serial.println(" hPa");

  Serial.print("Humidity = ");
  Serial.print(bme.humidity);
  Serial.println(" %");

  Serial.print("Gas = ");
  Serial.print(bme.gas_resistance / 1000.0);
  Serial.println(" KOhms");

  Serial.println("Air Quality: " + aqi);

  Serial.print("Approx. Altitude = ");
  Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA));
  Serial.println(" m");
  Serial.println();
  Serial.println();

  Serial.println("");
  Serial.print(date.year);
  Serial.print("/");
  Serial.print(date.month);
  Serial.print("/");
  Serial.print(date.date);
  Serial.print("/");
  Serial.print(utc.hour);
  Serial.print(":");
  Serial.print(utc.minute);
  Serial.print(":");
  Serial.print(utc.second);
  Serial.println();
  Serial.println((char)lat.latDirection);
  Serial.println((char)lon.lonDirection);

  // Serial.print("lat DDMM.MMMMM = ");
  // Serial.println(lat.latitude, 5);
  // Serial.print(" lon DDDMM.MMMMM = ");
  // Serial.println(lon.lonitude, 5);
  Serial.print("lat degree = ");
  Serial.println(lat.latitudeDegree, 6);
  Serial.print("lon degree = ");
  Serial.println(lon.lonitudeDegree, 6);

  Serial.print("star userd = ");
  Serial.println(starUserd);
  Serial.print("alt high = ");
  Serial.println(high);
  Serial.print("sog =  ");
  Serial.println(sog);
  Serial.print("cog = ");
  Serial.println(cog);
  Serial.print("gnss mode =  ");
  Serial.println(gnss.getGnssMode());
  Serial.println("");
  Serial.println("}");
  Serial.println("");

  Serial.println("smoke sensor value = ");
  sensorValue = analogRead(sensorPin);
  Serial.println(sensorValue);

  Serial.print("arduinoStatus: ");
  Serial.println(arduinoStatus);

  // Δημιουργία JSON δεδομένων
  String jsonData = "{\"temperature\":\"" + String(bme.temperature) + "\",\"humidity\":\"" + String(bme.humidity) + "\",\"pressure\":\"" + String(bme.pressure / 100.0) + "\",\"voc\":\"" + String(bme.gas_resistance / 1000.0) + "\",\"aqi\":\"" + String(aqi) + "\",\"arduino_status\":\"" + String(arduinoStatus) + "\",\"co2\":\"" + String(sensorValue) + "\",\"Detect_Fire\":\"" + String(Detect_Fire ? "true" : "false") + "\"}";

  // Αποστολή δεδομένων μέσω WiFi
  if (WiFi.status() == WL_CONNECTED) {
    client.post("/data", "application/json", jsonData);

    int statusCode = client.responseStatusCode();
    String response = client.responseBody();

    Serial.println("");
    Serial.print("Κωδικός κατάστασης: ");
    Serial.println(statusCode);
    Serial.print("Απάντηση: ");
    Serial.println(response);
    Serial.println("");

    if (statusCode == 200) {
      Serial.println("Τα δεδομένα εστάλησαν!");
      matrix.loadSequence(LEDMATRIX_ANIMATION_CHECK);
      matrix.play(true);
      if (response == "restart") {
        matrix.loadSequence(LEDMATRIX_ANIMATION_INFINITY_LOOP_LOADER);
        matrix.play(true);
      }
      delay(2000);
      matrix.loadFrame(LEDMATRIX_CLOUD_WIFI);
    } else {
      Serial.println("Σφάλμα!");
      arduinoStatus = "API Error";
      matrix.loadSequence(LEDMATRIX_ANIMATION_ATMEGA);
      matrix.play(true);
    }
    // Έλεγχος για εντολή επανεκκίνησης
    if (response == "restart") {
      arduinoStatus = "Arduino Restarting.....";
      huskylens.customText("Restarting.....", 0, 200);
      Serial.println("");
      Serial.println("Λήφθηκε εντολή επανεκκίνησης από το API");
      Serial.println("|||||>--- Arduino Reset ---<|||||");
      String jsonData = "{\"arduinoStatus\":\"" + String(arduinoStatus) + "\"}";
      client.post("/data", "application/json", jsonData);
      analogWrite(4, HIGH);

      delay(1500);
      analogWrite(7, LOW);
    }
  } else {
    Serial.println("Αποσυνδέθηκε από το WiFi ⨹");
    arduinoStatus = "WiFi Error";
    matrix.loadSequence(LEDMATRIX_ANIMATION_LOAD);
    matrix.play(true);
    checkWiFiConnection();
    analogWrite(4, HIGH);
  }

  Serial.print("arduinoStatus: ");
  Serial.println(arduinoStatus);
  if (arduinoStatus != "OK") { huskylens.customText("*", 0, 200); }
  Serial.println("_");
  delay(1000);
}

// Συνάρτηση για ανάγνωση πολλαπλών μετρήσεων από τους αισθητήρες και υπολογισμό του μέσου όρου
void readSensorData() {
  Serial.println("smoke sensor value : " + sensorValue);
  sensorValue = analogRead(sensorPin);
  Serial.print(sensorValue);
  if (sensorValue >= 100) {
    matrix.loadFrame(LEDMATRIX_DANGER);
    Serial.print("!!!!!!!!!!!!! detect smoke !!!!!!!!!!!!!!");
    String jsonData = "{\"co2\":\"" + String(sensorValue) + "\"}";
    client.post("/data", "application/json", jsonData);
    Serial.print("client.post smoke is max");
  }

  if (!bme.performReading()) {
    Serial.println("Failed to perform reading :(");
    arduinoStatus = "⨴ Adafruit_BME680 Failed to perform reading :( ";
    Serial.print("arduinoStatus: ");
    Serial.println(arduinoStatus);
    return;
  }
}

// Συνάρτηση για έλεγχο και επανασύνδεση WiFi
void checkWiFiConnection() {
  matrix.loadSequence(LEDMATRIX_ANIMATION_WIFI_SEARCH);
  matrix.play(true);
  if (WiFi.status() != WL_CONNECTED) {
    Serial.print("Επανασύνδεση στο WiFi ◌");
    while (WiFi.status() != WL_CONNECTED) {
      analogWrite(4, 0);

      WiFi.begin(ssid, pass);
      delay(500);
      Serial.print(".");
      analogWrite(4, HIGH);
    }
    Serial.println("Επανασύνδεση επιτυχής ⋰ ");
    printWifiStatus();
    matrix.loadFrame(LEDMATRIX_CLOUD_WIFI);
    analogWrite(4, 0);
  }
}
void printWifiStatus() {
  /* -------------------------------------------------------------------------- */
  // print the SSID of the network you're attached to:
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());

  // print your board's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);

  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print("signal strength ⨳ (RSSI):");
  Serial.print(rssi);
  Serial.println(" dBm");
}


// Συνάρτηση για τη λήψη δεδομένων από το HuskyLens
void huskylensData() {
  if (huskylens.request()) {
    if (huskylens.isLearned() && huskylens.available()) {
      HUSKYLENSResult result = huskylens.read();
      if (result.ID >= 5 && result.ID < 8) {
        huskylens.customText("fire", 230, 35);
        Serial.println("-- Φωτιά ανιχνεύθηκε! --");
        Detect_Fire = true;
        matrix.loadFrame(LEDMATRIX_DANGER);
        analogWrite(4, HIGH);
        String jsonData = "{\"temperature\":\"" + String(bme.temperature) + "\",\"humidity\":\"" + String(bme.humidity) + "\",\"arduino_status\":\"" + String(arduinoStatus) + "\",\"Detect_Fire\":\"" + String(Detect_Fire ? "true" : "false") + "\"}";
        client.post("/data", "application/json", jsonData);
        Serial.println("⨹} fire = true sent ! {⨹");
        huskylens.saveScreenshotToSDCard();
        huskylens.savePictureToSDCard();
        Serial.println("-- saveScreenshotToSDCard --");
      } else {
        Serial.println("Δεν ανιχνεύθηκε φλόγα.");
        huskylens.clearCustomText();
        huskylens.customText("DRONE CITY", 160, 200);
        Detect_Fire = false;
        analogWrite(4, 0);
      }
    } else {
      Serial.println("Δεν ανιχνεύθηκε.");
      analogWrite(4, HIGH);
    }
  } else {
    huskylens.customText("error", 230, 35);
    huskylens.customText("reboot", 200, 35);
    arduinoStatus = "Arduino Restarting.....";
    String jsonData = "{\"temperature\":\"" + String(bme.temperature) + "\",\"humidity\":\"" + String(bme.humidity) + "\",\"arduino_status\":\"" + String(arduinoStatus) + "\",\"Detect_Fire\":\"" + String(Detect_Fire ? "true" : "false") + "\"}";
    client.post("/data", "application/json", jsonData);
    Serial.println("Αποτυχία επικοινωνίας με το HuskyLens.");
    Serial.println("|||||>--- Arduino Reset ---<|||||");
    analogWrite(4, HIGH);
    delay(1000);
    analogWrite(7, LOW);
  }
}
